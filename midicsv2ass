#!/usr/bin/env bash

die() {
  echo "ERROR:" "$@" "Aborting." >&2
  exit 1
}

print_usage() {
  cat <<EOF
Usage: ${0##*/} lyrics-file [midicsv-file]
       ${0##*/} -h
Combines a lyrics file and the output of midicsv to produce k-timed ASS Dialogue
lines.

If midicsv-file is - or is not given, stdin is read.

The lyrics file is a plain text file, with each line producing an ASS Dialogue
line in the output. Each syllable is separated by a | character. There should be
one syllable per MIDI note.

The MIDI file from which the midicsv output is generated is expected to have a
single voice with no overlapping notes (non-conforming input will produce
unexpected results). Pitch is not considered, only durations. It is recommended
to add notes in place of long rests so a blank line will be generated instead of
extending the start of the next line.

OPTIONS
EOF
  sed -n '/^[[:space:]]*#::/s//   /p' "$0"
}

while getopts h opt; do
  case "$opt" in
    #:: -h	Show this help message.
    h)
      print_usage
      exit 0
      ;;
    *)
      print_usage >&2
      exit 2
      ;;
  esac
done

shift $((OPTIND - 1))

lyrics="$1"
midi_csv="${2-/dev/stdin}"

[[ "$midi_csv" = '-' ]] && midi_csv="/dev/stdin"

[[ -r "$lyrics" ]] || die "Could not read lyrics file ${lyrics}."
[[ -r "$midi_csv" ]] || die "Could not read MIDI CSV file ${midi_csv}."

tmpdir="$(mktemp -d)"
csv_to_ktimes="${tmpdir}/csv-to-ktimes.awk"
ktimed_syllables_to_ass="${tmpdir}/ktimed-syllables-to-ass.awk"

cleanup() {
  rm -rf -- "$tmpdir"
}

trap cleanup EXIT

######################################################################

main() {
  local syllables="${tmpdir}/ktimed-syllables.txt"

  add_ktimes_from_midicsv "$lyrics" "$midi_csv" >"$syllables"
  ktimes_to_ass "$syllables"
}

add_ktimes_from_midicsv() {
  local lyrics="$1"
  local midi_csv="$2"
  local eol_marker=$'\t'

  awk -F ' *, *' -f "$csv_to_ktimes" "$midi_csv" |
  paste -d '' - <(sed 's/$/'"$eol_marker"'/; s/|/\n/g' "$lyrics") |
  tr -d '\n' |
  tr "$eol_marker" '\n'
}

ktimes_to_ass() {
  local syllables="$1"
  local separator=$'\t'

  sed 's/}[^{]*{\\k/ + /g; s/^{\\k/0 /; s/}.*/ + 2 k 100.00 \/ p/' "$syllables" |
  dc |
  paste -d "$separator" - "$syllables" |
  awk -F "$separator" -f "$ktimed_syllables_to_ass"
}

prepare_awk_scripts() {
  # MIDI CSV to k-times, one syllable per line
  cat <<'EOF' >"$csv_to_ktimes"
BEGIN { first = 1 }
/Header/ { ticks = $6 }
/Tempo/ { tempo = $4 }
/Note_on_c/ {
  # assume alternating lines of on and off
  is_on = !is_on
  if (is_on) {
    start_time = $2
    gap = (start_time - end_time) * (tempo / 10000 / ticks) + gap_remainder
    gap_remainder = gap % 1

    # absorb small gaps into the previous syllable
    if (gap < 5) note_duration += gap
    if (!first) printf "{\\k%d}\n", note_duration
    if (gap >= 5) printf "{\\k%d}", gap

    first = 0
  } else {
    end_time = $2
    note_duration = (end_time - start_time) * (tempo / 10000 / ticks) + note_remainder
    note_remainder = note_duration % 1
  }
}
END { printf "{\\k%d}\n", note_duration + note_remainder }
EOF

  # k-timed syllables (one per line) to ASS Dialogue lines
  cat <<'EOF' >"$ktimed_syllables_to_ass"
{
  end = start + $1
  printf "Dialogue: 0,%d:%02d:%02.2f,%d:%02d:%02.2f,Default,,0,0,0,,%s\n",
    start / 60 / 60,
    start / 60 % 60,
    start % 60,
    end / 60 / 60,
    end / 60 % 60,
    end % 60,
    $2
  start = end
}
EOF
}

######################################################################

prepare_awk_scripts
main
